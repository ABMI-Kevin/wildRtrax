---
title: 'Pre-processing in wildRtrax'
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{using-functions-from-wildRtrax}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = '#>'
)

```

## Pre-processing

This vignette describes several pre-processing tools available in the `wildRtrax` package. 

### Scanning audio files from a directory

The `wt_audio_scanner()` function reads in audio files (either wac or wav format) from a local directory and outputs useful metadata.


```{r setup, echo = F, include = T, warning = F, message = F}
# Attach packages

library(wildRtrax)
library(vroom)

```

```{r, echo=TRUE, include=TRUE, eval=TRUE}
# Root directory
root <- '/volumes/GoogleDrive/Shared drives/wildRtrax/data/example'

# Scan data
d <- wt_audio_scanner(root, file_type = 'wav')

# View
head(d)

# Filter recordings based on criteria

```

### Running the QUT Ecoacoustics AnalysisPrograms software on a wt_* standard data set

The `wt_run_ap()` function allows you to run the QUT Analysis Programs [(AP.exe)](https://ap.qut.ecoacoustics.info/) on your audio data. Note that you must have the AP program installed on your computer. See more here [(Towsey et al., 2018)](https://researchoutput.csu.edu.au/ws/portalfiles/portal/28556441/28544328_Published_article.pdf). 

```{r echo=TRUE, include=T, eval=F, warning = F, message = F}
#Use the wt_* tibble to execute the AP on the files

#wt_run_ap(x = d, output_dir = paste0(root, 'ap_outputs'), path_to_ap = '/volumes/GoogleDrive/Shared drives/wildRtrax/data/AP')

```

```{r echo=TRUE, include=T, eval=F, warning = F, message = F} 
#Return the metadata obtained from AP
#Extract the index values - find the files
index_files <- fs::dir_ls(path = '/volumes/GoogleDrive/Shared drives/wildRtrax/data/ap_example',
                   regexp = '*Towsey.Acoustic.Indices.csv',
                   #This contains the vector data to the average of each index
                   recurse = TRUE)

#Which acoustic indices do you want to use?
index_list <-
  c(
    'Snr',
    'BackgroundNoise',
    'AcousticComplexity',
    'TemporalEntropy',
    'Ndsi',
    'ResultMinute',
    'FileName'
  )

#vroom together the indices you want from all the csvs
test_indices <- vroom(index_files, col_select = index_list)

#Join the index values to the wt_audio_scanner tibble
test_join <-
  d %>% inner_join(., test_indices, by = c('file_name' = 'FileName')) %>%
  pivot_longer(cols = Snr:Ndsi,
               names_to = 'index_variable',
               values_to = 'index_value') %>%
  #Plot a graph of the indices
  ggplot(.,
         aes(x = ResultMinute, y = index_value, colour = index_variable)) +
  geom_point() +
  blanktheme +
  facet_wrap(~ index_variable, ncol = 1)

test_join
```

### Applying a limited amplitude filter

We can use the `wt_signal_level()` function to search for sounds that exceed a certain amplitude threshold. 

```{r echo=TRUE, include=TRUE, eval=TRUE}
# Example audio file
path_to_file <- d$file_path[3]

# Run
s <- wt_signal_level(path = path_to_file, 
                     fmin = 5000, 
                     fmax = 10000, 
                     threshold = 20, 
                     channel = 'left', 
                     aggregate = 5)

# Return a list object, with parameters stored
str(s)

# We can view the output:
s['output']
# We have eleven detections that exceeded this threshold.

```

